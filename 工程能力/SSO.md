# 单点登录
在多个应用系统中，用户只需要登陆一次就可以访问所有相互信任的应用系统。  
SSO 一般都需要一个独立的`认证中心(passport)`, 子系统的登录均需要通过`认证中心`通过认证。子系统本身不参与登录操作。  
只要一次登录成功，`认证中心`会办法一个token给子系统，这个token
可以在所有子系统中进行成功认证。



## 如何实现单点登录

1. 同域名下的登录。
 - `cookie`的`domain`属性设置为当前域的父域。并且父域的`cookie`会被子域所共享。`path`属性默认为`web`应用的上下文路径。
 - 利用这个特点，将`cookie`的`domain`属性设置为父域的域名(主域名)，同时将`cookie`的`path`属性设置为根路径，将`SessionID`或者`Token`保存到父域中。这样所有的子域应用就都可以访问这个`cookie`。
- 应用系统的域名需要建立在共同的主域名下，举例来说：`tieba.baidu.com`和`map.baidu.com`，都有主域名`baidu.com`。
2. 不同域名下的单点登录。
- 如概述所言，需要建立一个认证中心，专门处理登录服务。
- 用户统一在认证中心登录，成功后，认证中心记录用户的登陆状态。并将`token`写入`cookie`（这个`cookie`是认证中心的，应用系统不可访问）。
- 应用系统检查当前请求有没有`token`,如果没有，说明用户在当前系统中尚未登录；那么就将页面跳转至认证中心。
- 由于这个操作会将认证中心的 `Cookie` 自动带过去，因此，认证中心能够根据 `Cookie` 知道用户是否已经登录过了。
- 如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录。
- 如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 `URL `，并在跳转前生成一个 `Token`，拼接在目标` URL` 的后面，回传给目标应用系统
- 应用系统拿到 `Token `之后，还需要向认证中心确认下 `Token` 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 `Token `写入` Cookie`，然后给本次访问放行。（注意这个 `Cookie` 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 `Token`，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了


单点登录的流程图如下所示：

 ![](https://static.vue-js.com/2422bc40-8c84-11eb-ab90-d9ae814b240d.png)

- 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数

- sso认证中心发现用户未登录，将用户引导至登录页面
- 用户输入用户名密码提交登录申请
- sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌
- sso认证中心带着令牌跳转会最初的请求地址（系统1）
- 系统1拿到令牌，去sso认证中心校验令牌是否有效
- sso认证中心校验令牌，返回有效，注册系统1
- 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源
- 用户访问系统2的受保护资源
- 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
- sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌
- 系统2拿到令牌，去sso认证中心校验令牌是否有效
- sso认证中心校验令牌，返回有效，注册系统2
- 系统2使用该令牌创建与用户的局部会话，返回受保护资源

用户登录成功之后，会与`sso`认证中心及各个子系统建立会话，用户与`sso`认证中心建立的会话称为全局会话

用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过`sso`认证中心

全局会话与局部会话有如下约束关系：

- 局部会话存在，全局会话一定存在
- 全局会话存在，局部会话不一定存在
- 全局会话销毁，局部会话必须销毁